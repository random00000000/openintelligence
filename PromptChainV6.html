<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Data Processor – Prompt Chain</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 900px;
      margin: 20px auto;
      line-height: 1.4;
    }
    h1 {
      margin-bottom: 8px;
    }
    #steps {
      margin: 16px 0;
      border: 1px solid #444;
      padding: 10px;
      border-radius: 4px;
    }
    .step {
      border-bottom: 1px solid #333;
      padding: 8px 0;
    }
    .step:last-child {
      border-bottom: none;
    }
    .step-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      font-size: 0.95rem;
    }
    .step-title {
      font-weight: 600;
    }
    .step-remove {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 0.85rem;
      color: #c00;
    }
    textarea {
      width: 100%;
      box-sizing: border-box;
      font-family: inherit;
    }
    #initialInput, .step-prompt {
      min-height: 70px;
    }
    .step-output {
      margin-top: 4px;
      border: 1px solid #555;
      border-radius: 3px;
      padding: 6px;
      font-size: 0.9rem;
      white-space: pre-wrap;
      max-height: 150px;
      overflow-y: auto;
      background: #111;
      color: #ddd;
    }
    #controls {
      margin-top: 10px;
    }
    button {
      margin-top: 8px;
      padding: 6px 10px;
      cursor: pointer;
    }
    #finalOutput {
      margin-top: 16px;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 8px;
      background: #050505;
      color: #eee;
      white-space: pre-wrap;
      max-height: 220px;
      overflow-y: auto;
    }
    #status {
      margin-top: 6px;
      font-size: 0.85rem;
      color: #666;
    }
    label {
      display: block;
      margin: 8px 0 4px;
      font-size: 0.95rem;
    }

    /* --- chain save/load UI --- */
    #chainControls {
      margin-top: 14px;
      padding: 8px;
      border-radius: 4px;
      font-size: 0.9rem;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      background: #191b1e;
      border: 1px solid #292b2f;
    }
    #chainControls input[type="text"], #savedChainsSelect {
      padding: 3px 5px;
      font-size: 0.9rem;
      border: 1px solid #35363a;
      border-radius: 2px;
      background: #23252a;
      color: #eee;
    }
    #chainControls button {
      font-size: 0.92rem;
      padding: 4px 9px;
      border-radius: 2px;
      background: #189;
      color: #fff;
      border: none;
      min-width: 70px;
      white-space: nowrap;
      box-shadow: none;
      transition: background 0.15s;
    }
    #chainControls button:hover {
      background: #127399;
    }
    #chainControls label {
      font-size: 0.93rem;
      margin-bottom: 1px;
      color: #c8daef;
    }
    #chainControls {
      box-shadow: 0 1.5px 12px 1px #0005;
    }
    .topInfo {
      background: linear-gradient(to right, #181d20 70%, #16171a 100%);
      color: #aaa;
      padding: 16px 14px 10px 14px;
      border-radius: 6px;
      margin-bottom: 13px;
      box-shadow: 0 1px 8px #0003;
      font-size: 1.02rem;
      font-weight: 400;
      transition: background 0.15s;
    }
    .topInfo h1 {
      font-size: 1.17em;
      color: #d1e8ff;
      letter-spacing: 0.01em;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .topInfo .hideBtn {
      float: right;
      background: none;
      color: #25cfeb;
      border: none;
      font-size: 1.02rem;
      font-weight: 400;
      cursor: pointer;
      padding: 0 0 0 7px;
    }
  </style>
</head>
<body>
  <div class="topInfo" id="topInfo">
    <button class="hideBtn" id="hideTopBtn">Hide info</button>
    <h1>Data Processor – Prompt Chain</h1>
    <p style="font-size:0.92rem; color:#7aa; margin-bottom:0;">
      Define a sequence of prompts. The output of each step becomes the input of the next one.
    </p>
  </div>

  <!-- Chain save/load controls (now above system prompt) -->
  <div id="chainControls">
    <div>
      <label>Chain name:</label>
      <input type="text" id="chainName" placeholder="e.g. Summarize → Translate → Format" />
    </div>
    <button id="saveChainBtn" type="button">Save</button>
    <div>
      <label>Saved chains:</label>
      <select id="savedChainsSelect">
        <option value="">— select —</option>
      </select>
    </div>
    <button id="loadChainBtn" type="button">Load</button>
    <button id="deleteChainBtn" type="button">Delete</button>
    <button id="exportChainBtn" type="button">Export</button>
    <button id="importChainBtn" type="button">Import</button>
    <input type="file" id="importChainFile" style="display:none;" accept=".json" />
    <button id="toggleInstBtn" type="button" style="margin-left: auto;">Show saving instructions</button>
  </div>

  <!-- Instructions, hidden by default -->
  <div id="saveInstSection" style="display: none; font-size:0.9rem; color:#558; margin-bottom:8px; max-width: 640px;">
    <div>
      Tip: For long-term saves and easy transfer, use <b>Export to File</b> to download a JSON chain. Save it in a <b>data</b> folder next to this HTML file (<code>data/yourChain.json</code>). To load, use <b>Import from File</b> and pick your file from the folder.<br>
      <span style="color:#b22;">Note: Browsers require you to select the file each time for security; direct automatic save/load to disk is not allowed.</span>
    </div>
  </div>

  <label>
    Global system prompt (optional):
    <textarea id="system" rows="2" placeholder="You are a helpful text-processing assistant."></textarea>
  </label>

  <label>
    Initial input data:
    <textarea id="initialInput" rows="4" placeholder="Paste or type the starting text here..."></textarea>
  </label>

  <!-- Step 0 model output -->
  <h3 style="margin-top:8px;">Initial data snapshot (Step 0 output)</h3>
  <div id="initialOutput" class="step-output">
    Will show the model's output when running the initial input as Step 0.
  </div>

  <div id="steps"></div>

  <div id="controls">
    <button id="addStepBtn">+ Add step</button>
    <button id="runBtn" style="margin-left: 10px;">Run chain</button>
    <button id="clearOutputsBtn" style="margin-left: 10px;">Clear outputs</button>
  </div>

  <div id="status"></div>

  <h2 style="margin-top:18px;">Final output</h2>
  <div id="finalOutput" placeholder="Final result will appear here..."></div>

  <!-- Output to file controls -->
  <div id="outputFileControls" style="margin-top:22px; padding:12px 10px 9px 10px; background:#191b1e; border:1px solid #2a2d33; border-radius:5px; max-width: 610px; display: flex; align-items: center; gap: 15px;">
    <input type="checkbox" id="saveOutputCheckbox">
    <label for="saveOutputCheckbox" style="margin:0;font-size:1rem;color:#0cf;">Save output to file on run</label>
    <button id="pickFolderBtn" style="display:none;">Choose Output Folder…</button>
    <span id="outputFolderStatus" style="font-size:0.92rem;color:#6ad;margin-left:6px;"></span>
  </div>

  <!-- Batch run controls (minimalistic) -->
  <div id="batchControls" style="margin-top:10px; font-size:0.9rem;">
    <input type="checkbox" id="batchRunCheckbox">
    <label for="batchRunCheckbox" style="display:inline;margin-left:4px;">Run multiple times</label>
    <span id="batchRunControls" style="display:none; margin-left:10px;">
      Runs:
      <input type="number" id="batchRunCount" min="1" max="50" value="5" style="width:60px;">
    </span>
  </div>

  <script>
    // -------- CONFIG --------
    const API_URL = 'http://localhost:11434/api/chat'; // your Ollama API
    const MODEL   = 'deepseek-r1:8b';                  // model name

    // -------- DOM --------
    const systemEl         = document.getElementById('system');
    const initialInputEl   = document.getElementById('initialInput');
    const initialOutputEl  = document.getElementById('initialOutput');
    const stepsContainer   = document.getElementById('steps');
    const addStepBtn       = document.getElementById('addStepBtn');
    const runBtn           = document.getElementById('runBtn');
    const clearOutputsBtn  = document.getElementById('clearOutputsBtn');
    const finalOutputEl    = document.getElementById('finalOutput');
    const statusEl         = document.getElementById('status');

    // Chain save/load elements
    const chainNameEl        = document.getElementById('chainName');
    const saveChainBtn       = document.getElementById('saveChainBtn');
    const loadChainBtn       = document.getElementById('loadChainBtn');
    const deleteChainBtn     = document.getElementById('deleteChainBtn');
    const savedChainsSelect  = document.getElementById('savedChainsSelect');
    const importChainFile    = document.getElementById('importChainFile');

    // --- OUTPUT TO FILE DOM WIRING & STATE ---
    const saveOutputCheckbox = document.getElementById('saveOutputCheckbox');
    const pickFolderBtn = document.getElementById('pickFolderBtn');
    const outputFolderStatus = document.getElementById('outputFolderStatus');
    let outputFolderHandle = null; // For File System Access API
    let canRememberOutputFolder = false;

    // --- BATCH RUN DOM ---
    const batchRunCheckbox   = document.getElementById('batchRunCheckbox');
    const batchRunControls   = document.getElementById('batchRunControls');
    const batchRunCountInput = document.getElementById('batchRunCount');

    if (batchRunCheckbox) {
      batchRunCheckbox.addEventListener('change', () => {
        batchRunControls.style.display = batchRunCheckbox.checked ? '' : 'none';
      });
    }

    // Only show pick folder if API present
    if ('showDirectoryPicker' in window) {
      canRememberOutputFolder = true;
    }
    saveOutputCheckbox.addEventListener('change', () => {
      if (saveOutputCheckbox.checked && canRememberOutputFolder) {
        pickFolderBtn.style.display = '';
      } else {
        pickFolderBtn.style.display = 'none';
        outputFolderStatus.textContent = '';
      }
    });

    // --- Folder Picker/Remember Logic ---
    const OUTPUT_FOLDER_KEY = 'promptChainOutputFolderV1';

    async function verifyFolderAccess(handle) {
      if (!handle) return false;
      if ((await handle.queryPermission?.({ mode: 'readwrite' })) === 'granted') return true;
      const perm = await handle.requestPermission?.({ mode: 'readwrite' });
      return perm === 'granted';
    }

    async function rememberPickedFolder(handle) {
      if (!handle || !handle.kind || !handle.name) return;
      try {
        const serialized = await window.showDirectoryPicker && handle;
        if (serialized) {
          window.localStorage.setItem(OUTPUT_FOLDER_KEY, '1');
          outputFolderHandle = handle;
        }
      } catch(e) {
        // ignore
      }
    }

    async function tryRestoreFolderOnStartup() {
      if (!canRememberOutputFolder) {
        pickFolderBtn.style.display = 'none';
        outputFolderStatus.textContent = 'Output folder saves are not supported in this browser.';
        saveOutputCheckbox.disabled = true;
        return;
      }
      pickFolderBtn.style.display = saveOutputCheckbox.checked ? '' : 'none';
      if (outputFolderHandle && (await verifyFolderAccess(outputFolderHandle))) {
        outputFolderStatus.textContent = `Saving to: ${outputFolderHandle.name}`;
      } else {
        outputFolderStatus.textContent = '';
        outputFolderHandle = null;
      }
    }

    pickFolderBtn.addEventListener('click', async () => {
      try {
        const handle = await window.showDirectoryPicker();
        if (!(await verifyFolderAccess(handle))) {
          outputFolderStatus.textContent = 'Permission denied for this folder.';
          outputFolderHandle = null;
          return;
        }
        outputFolderHandle = handle;
        await rememberPickedFolder(handle);
        outputFolderStatus.textContent = `Saving to: ${handle.name}`;
      } catch (err) {
        outputFolderStatus.textContent = 'Folder pick canceled.';
        outputFolderHandle = null;
      }
    });
    setTimeout(tryRestoreFolderOnStartup, 20);

    function setOutputFolderStatus(text, type = '') {
      outputFolderStatus.textContent = text;
      outputFolderStatus.style.color = (type === 'error') ? '#f33' :
                                       (type === 'success') ? '#6ad' : '#6ad';
      if (type === 'error' && pickFolderBtn) {
        pickFolderBtn.style.display = '';
      }
    }

    // -------- STATE --------
    let stepCounter = 0;
    const STORAGE_KEY = 'promptChains_v1';

    // -------- HELPERS --------
    function createStep(initialPrompt = '') {
      stepCounter++;

      const step = document.createElement('div');
      step.className = 'step';

      const header = document.createElement('div');
      header.className = 'step-header';

      const title = document.createElement('span');
      title.className = 'step-title';
      title.textContent = 'Step ' + stepCounter;

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'step-remove';
      removeBtn.textContent = 'Remove';
      removeBtn.addEventListener('click', () => {
        stepsContainer.removeChild(step);
        renumberSteps();
      });

      header.appendChild(title);
      header.appendChild(removeBtn);

      const promptArea = document.createElement('textarea');
      promptArea.className = 'step-prompt';
      promptArea.placeholder = 'Describe what this step should do with the input...';
      promptArea.value = initialPrompt;

      const output = document.createElement('div');
      output.className = 'step-output';
      output.textContent = 'Output will appear here...';

      step.appendChild(header);
      step.appendChild(promptArea);
      step.appendChild(output);

      stepsContainer.appendChild(step);
      return step;
    }

    function renumberSteps() {
      const steps = stepsContainer.querySelectorAll('.step');
      let n = 1;
      steps.forEach(step => {
        const titleEl = step.querySelector('.step-title');
        titleEl.textContent = 'Step ' + n;
        n++;
      });
      stepCounter = steps.length;
    }

    async function callOllama(messages) {
      const res = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: MODEL,
          messages,
          stream: false
        })
      });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();
      return data.message?.content || '';
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    // -------- CHAIN SAVE / LOAD (localStorage) --------

    function getStoredChains() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        if (typeof parsed !== 'object' || parsed === null) return {};
        return parsed;
      } catch (e) {
        console.error('Failed to read chains from localStorage', e);
        return {};
      }
    }

    function saveStoredChains(chains) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(chains));
      } catch (e) {
        console.error('Failed to save chains to localStorage', e);
      }
      updateSavedChainsSelect();
    }

    function captureCurrentChain() {
      const steps = stepsContainer.querySelectorAll('.step');
      const stepPrompts = Array.from(steps).map(step =>
        step.querySelector('.step-prompt').value || ''
      );
      return {
        system: systemEl.value || '',
        initialInput: initialInputEl.value || '',
        steps: stepPrompts
      };
    }

    function loadChainIntoUI(chain) {
      systemEl.value = chain.system || '';
      initialInputEl.value = chain.initialInput || '';
      stepsContainer.innerHTML = '';
      stepCounter = 0;

      const prompts = Array.isArray(chain.steps) ? chain.steps : [];
      if (prompts.length === 0) {
        createStep('');
      } else {
        prompts.forEach(p => createStep(p));
      }
      clearOutputs();
    }

    function updateSavedChainsSelect() {
      const chains = getStoredChains();
      const currentValue = savedChainsSelect.value;

      while (savedChainsSelect.firstChild) {
        savedChainsSelect.removeChild(savedChainsSelect.firstChild);
      }

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = '— select a chain —';
      savedChainsSelect.appendChild(placeholder);

      Object.keys(chains).sort().forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        savedChainsSelect.appendChild(opt);
      });

      if (chains[currentValue]) {
        savedChainsSelect.value = currentValue;
      } else {
        savedChainsSelect.value = '';
      }
    }

    function handleSaveChain() {
      const name = chainNameEl.value.trim();
      if (!name) {
        alert('Please enter a name for this chain.');
        return;
      }

      const chains = getStoredChains();
      const exists = !!chains[name];

      if (exists) {
        const overwrite = confirm('A chain with this name already exists. Overwrite it?');
        if (!overwrite) return;
      }

      const chainDef = captureCurrentChain();
      chains[name] = chainDef;
      saveStoredChains(chains);
      setStatus('Chain "' + name + '" saved.');
    }

    function handleLoadChain() {
      const name = savedChainsSelect.value;
      if (!name) {
        alert('Please select a saved chain to load.');
        return;
      }

      const chains = getStoredChains();
      const chain = chains[name];
      if (!chain) {
        alert('Chain not found.');
        updateSavedChainsSelect();
        return;
      }

      loadChainIntoUI(chain);
      chainNameEl.value = name;
      setStatus('Chain "' + name + '" loaded.');
    }

    function handleDeleteChain() {
      const name = savedChainsSelect.value || chainNameEl.value.trim();
      if (!name) {
        alert('Select a chain or type its name to delete.');
        return;
      }

      const chains = getStoredChains();
      if (!chains[name]) {
        alert('No saved chain with that name.');
        return;
      }

      const confirmDelete = confirm('Delete chain "' + name + '"? This cannot be undone.');
      if (!confirmDelete) return;

      delete chains[name];
      saveStoredChains(chains);
      if (savedChainsSelect.value === name) {
        savedChainsSelect.value = '';
      }
      if (chainNameEl.value.trim() === name) {
        chainNameEl.value = '';
      }
      setStatus('Chain "' + name + '" deleted.');
    }

    // -------- FILE SAVE FOR EACH RUN --------
    async function saveFinalOutputToFile(outputText, runIndex, totalRuns) {
      if (!outputText || !saveOutputCheckbox || !saveOutputCheckbox.checked) return;

      const now = new Date();
      const pad = n => String(n).padStart(2, '0');
      const base = `PromptChainOutput_${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}` +
                   `_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
      const suffix = totalRuns > 1 ? `_R${pad(runIndex)}` : '';
      const fname = `${base}${suffix}.txt`;

      if (outputFolderHandle && canRememberOutputFolder) {
        try {
          const fileHandle = await outputFolderHandle.getFileHandle(fname, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(outputText);
          await writable.close();
          setOutputFolderStatus(`Saved: ${fname}`, 'success');
        } catch (e) {
          setOutputFolderStatus('[Error saving file: ' + (e.message || e) + ']', 'error');
          pickFolderBtn.style.display = '';
        }
      } else {
        const blob = new Blob([outputText], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(a.href);
          document.body.removeChild(a);
        }, 250);
        setOutputFolderStatus('[No folder selected, so used download fallback.]', 'error');
      }
    }

    // -------- SINGLE RUN EXECUTION (fresh context each time) --------
    async function runSingleChainRun({ initialText, globalSystem, runIndex, totalRuns }) {
      const steps = stepsContainer.querySelectorAll('.step');
      const prefix = totalRuns > 1 ? `Run ${runIndex}/${totalRuns}: ` : '';

      // STEP 0
      setStatus(prefix + 'Step 0 (initial input)...');

      const messages0 = [];
      if (globalSystem) {
        messages0.push({ role: 'system', content: globalSystem });
      }
      messages0.push({ role: 'user', content: initialText });

      const step0Result = (await callOllama(messages0)).trim();
      const step0Output = step0Result || '[Empty output]';

      initialOutputEl.textContent = step0Output;
      let currentText = step0Result || initialText;

      // STEPS 1..N
      let stepIndex = 0;
      for (const step of steps) {
        stepIndex++;
        const promptEl = step.querySelector('.step-prompt');
        const outputEl = step.querySelector('.step-output');
        const instruction = promptEl.value.trim();

        if (!instruction) {
          outputEl.textContent = '[Skipped – empty prompt]';
          continue;
        }

        outputEl.textContent = 'Running...';
        setStatus(prefix + 'Running step ' + stepIndex + ' of ' + steps.length + '...');

        const messages = [];
        if (globalSystem) {
          messages.push({ role: 'system', content: globalSystem });
        }
        messages.push({
          role: 'user',
          content:
            'Instruction:\n' + instruction +
            '\n\n--- INPUT START ---\n' +
            currentText +
            '\n--- INPUT END ---\n\n' +
            'Return ONLY the transformed output.'
        });

        const result = (await callOllama(messages)).trim();
        currentText = result || currentText;
        outputEl.textContent = result || '[Empty output]';

        setStatus(prefix + 'Completed step ' + stepIndex + ' of ' + steps.length);
      }

      finalOutputEl.textContent = currentText;
      await saveFinalOutputToFile(currentText, runIndex, totalRuns);
    }

    // -------- CORE: RUN CHAIN (supports N runs) --------
    async function runChain() {
      const initialText = initialInputEl.value.trim();
      if (!initialText) {
        alert('Please provide some initial input data.');
        return;
      }

      const steps = stepsContainer.querySelectorAll('.step');
      if (steps.length === 0) {
        alert('Add at least one step.');
        return;
      }

      const globalSystem = systemEl.value.trim();
      let totalRuns = 1;
      if (batchRunCheckbox && batchRunCheckbox.checked) {
        const raw = parseInt(batchRunCountInput.value, 10);
        if (!isNaN(raw) && raw > 0) {
          totalRuns = Math.min(raw, 50); // simple safety cap
        }
      }

      runBtn.disabled = true;
      addStepBtn.disabled = true;
      clearOutputsBtn.disabled = true;

      // Clear once at the start; UI then shows the last run.
      clearOutputs();
      setStatus(totalRuns > 1 ? `Running ${totalRuns} runs...` : 'Running chain...');

      try {
        for (let i = 1; i <= totalRuns; i++) {
          await runSingleChainRun({
            initialText,
            globalSystem,
            runIndex: i,
            totalRuns
          });
        }
        setStatus(totalRuns > 1 ? `All ${totalRuns} runs finished.` : 'Chain finished.');
      } catch (err) {
        console.error(err);
        setStatus('Error: ' + err.message);
      } finally {
        runBtn.disabled = false;
        addStepBtn.disabled = false;
        clearOutputsBtn.disabled = false;
      }
    }

    function clearOutputs() {
      finalOutputEl.textContent = '';
      const steps = stepsContainer.querySelectorAll('.step-output');
      steps.forEach(out => {
        out.textContent = 'Output will appear here...';
      });
      initialOutputEl.textContent = 'Will show the model\'s output when running the initial input as Step 0.';
      setStatus('');
    }

    // -------- EVENT WIRES --------
    addStepBtn.addEventListener('click', () => createStep());
    runBtn.addEventListener('click', runChain);
    clearOutputsBtn.addEventListener('click', clearOutputs);

    // save/load/delete events
    saveChainBtn.addEventListener('click', handleSaveChain);
    loadChainBtn.addEventListener('click', handleLoadChain);
    deleteChainBtn.addEventListener('click', handleDeleteChain);

    // Export to file button
    const exportChainBtn = document.getElementById('exportChainBtn');
    exportChainBtn.addEventListener('click', async () => {
      const chainDef = captureCurrentChain();
      const name = (chainNameEl.value.trim() || 'chain').replace(/[^a-z0-9\-_]+/gi, '_');
      const json = JSON.stringify(chainDef, null, 2);
      if (window.showSaveFilePicker) {
        try {
          const opts = {
            types: [
              {
                description: 'JSON Files',
                accept: { 'application/json': ['.json'] },
              },
            ],
            suggestedName: `${name}.json`,
          };
          const handle = await window.showSaveFilePicker(opts);
          const writable = await handle.createWritable();
          await writable.write(json);
          await writable.close();
          setStatus('Chain exported successfully.');
          return;
        } catch (err) {
          if (err.name !== 'AbortError') alert('Export failed: ' + err.message);
          return;
        }
      }
      const fileName = `${name}.json`;
      const blob = new Blob([json], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      setTimeout(() => {
        URL.revokeObjectURL(link.href);
        document.body.removeChild(link);
      }, 250);
      setStatus('Chain exported (basic download).');
    });

    // Import button wiring
    const importChainBtn = document.getElementById('importChainBtn');
    importChainBtn.addEventListener('click', () => {
      importChainFile.value = '';
      importChainFile.click();
    });
    importChainFile.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const chain = JSON.parse(evt.target.result);
          loadChainIntoUI(chain);
          setStatus('Chain loaded from file.');
        } catch (err) {
          alert('Failed to parse JSON file.');
        }
      };
      reader.readAsText(file);
    });

    // Toggle instructions visibility
    const toggleInstBtn = document.getElementById('toggleInstBtn');
    const saveInstSection = document.getElementById('saveInstSection');
    let instShown = false;
    toggleInstBtn.addEventListener('click', () => {
      instShown = !instShown;
      saveInstSection.style.display = instShown ? '' : 'none';
      toggleInstBtn.textContent = instShown ? 'Hide saving instructions' : 'Show saving instructions';
    });

    // Toggle top area info
    const topInfo = document.getElementById('topInfo');
    const hideTopBtn = document.getElementById('hideTopBtn');
    hideTopBtn.addEventListener('click', () => {
      topInfo.style.display = 'none';
    });

    // Ctrl+Enter / Cmd+Enter on initial input
    initialInputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        runChain();
      }
    });

    // Init
    createStep('First, summarize the input clearly in 3–5 bullet points.');
    updateSavedChainsSelect();
  </script>
</body>
</html>
